# -*- coding: utf-8 -*-
"""
scn.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:copyright: Copyright (c) 2015, National Institute of Information and Communications Technology.All rights reserved.
:license: GPL3, see LICENSE for more details.
"""

import time
import copy
import json

from pox.core import core
from pox.lib.revent import Event, EventMixin
from pox.lib.recoco import Timer
from pox.lib.util import dpidToStr
from pox.lib.packet.ethernet import ethernet
from pox.lib.addresses import IPAddr, EthAddr
from pox.topology.topology import Host, HostJoin, HostLeave, SwitchJoin
import pox.openflow.libopenflow_01 as of
from pox.openflow.topology import (
        OpenFlowPort, OpenFlowSwitch, OpenFlowTopology,
        RECONNECT_TIMEOUT, SwitchConnectionUp, SwitchConnectionDown
    )
from pox.openflow.flow_table import SwitchFlowTable, TableEntry

from scn.parser import IP
from scn.parser import INTFNAME
from scn.parser import SPEED


log = core.getLogger()

################################################################################
#                              Classes definitions                             #
################################################################################
class ScnLinkUpdatedEv(Event):
    """ Event Class for ScnLink updated
    """
    EVENT_NAME = 'ScnLinkUpdatedEv'

    def __init__(self, updated, before):
        Event.__init__(self)
        self.link = updated
        self.before = before

    def __repr__(self):
        return "%s --> %s" % (str(self.before), str(self.link))

    def __str__(self):
        return "%s --> %s" % (str(self.before), str(self.link))


class ScnLink(EventMixin):
    """ Class represented Link between OFP and OFP
        link has a direction (src -> dst).
    """
    _eventMixin_events = set([
        ScnLinkUpdatedEv
    ])

    def __init__(self, src_ofp, dst_ofp):
        EventMixin.__init__(self)
        if not src_ofp or not isinstance(src_ofp, ScnOpenFlowPort):
            log.warn("no src ofp")
            return
        if not dst_ofp or not isinstance(dst_ofp, ScnOpenFlowPort):
            log.warn("no src ofp")
            return

        self.src_ofp = src_ofp
        self.dst_ofp = dst_ofp

        self.rx_bytes = 0
        self.time = time.time()
        self.used_bw = 0

        #unit used for the treatment of stats
        self.stat_unit = "bit"

        #list of Path using this link.
        self.reserved = []
        self._id = id(self) # is it enough? we will need some id logic.

        self.cookies = [] #backward compatible for bwFlowBalancing class.

        if core.stats:
            core.stats.addListenerByName("PortStatsEv", self._handle_PortStatsEv)
            self.listenTo(core.stats)

    def get_id(self):
        """return id
            generated by id method.
        """
        return self._id

    def apply_flow_entry(self, cookie, src, dst, app_id = None, is_last = False):
        """apply flow table
            cookie[int] -- cookie number.
            src[Peer]   -- src node description
            dst[Peer]   -- dst node description
            app_id      -- tos/vlan
            is_last[bool] -- last link should set dst node mac address.
        """
        cookie = int(cookie)

        flow_msg = of.ofp_flow_mod()
        flow_msg.actions = [
            of.ofp_action_output(port = self.src_ofp.number, max_len = 0)
        ]
        flow_msg.cookie = cookie
        match = self.__get_match_object__(src, dst, app_id)
        flow_msg.match = match

        log.info(str(flow_msg))
        self.src_ofp.ofs.installFlow(flow_msg)

        if is_last:
            self.__apply_last_ofs__(match, cookie, dst)

    def __get_match_object__(self, src, dst, app_id):
        """get match object.
            use to flow table entry.
        """
        match = of.ofp_match()
        match.nw_src = src.ipaddr
        match.nw_dst = dst.ipaddr

        if app_id:
            app_id = app_id.get_id()
            setattr(match, app_id["type"] , app_id["value"])

        match.dl_type = ethernet.IP_TYPE
        protocol = self.__get_protocol__(src.protocol, dst.protocol)
        if protocol:
            match.nw_proto = protocol
        return match

    def __apply_last_ofs__(self, match, cookie, dst):
        """apply flow entry to ofs nearby node.
        """
        dst_node = self.dst_ofp.ofs.getHost(dst.ipaddr)
        if not dst_node:
            raise AssertionError("Cannot find Host from IP: %s" % dst.ipaddr)

        flow_msg = of.ofp_flow_mod()
        flow_msg.match = match
        flow_msg.cookie = cookie
        flow_msg.actions = [
            of.ofp_action_dl_addr.set_dst(dst_node.macAddr),
            of.ofp_action_output(port = dst_node.ofp.number, max_len = 0)
        ]

        log.debug(str(flow_msg))
        self.dst_ofp.ofs.installFlow(flow_msg)

    def __get_protocol__(self, src_protocol, dst_protocol):
        """decide network protocol if you need it.
        """
        pass

    def remove_flow_entry(self, cookie, src, dst, app_id):
        """remove flow entry.
            cookie[int] -- cookie number.
            src[Peer]   -- src node description
            dst[Peer]   -- dst node description
            app_id      -- tos/vlan
        """
        cookie = int(cookie)

        flow_msg = of.ofp_flow_mod()
        flow_msg.cookie = cookie
        match = self.__get_match_object__(src, dst, app_id)
        flow_msg.match = match

        self.src_ofp.ofs.removeFlow(flow_msg)
        self.dst_ofp.ofs.removeFlow(flow_msg)

    def getBandwidthUsed(self):
        """get used bandwidth.
        """
        return self.used_bw

    def getMaxBandwidthTheorical(self):
        """ get Theorical Max.
        """
        return self.dst_ofp.max_speed

    def getBandwidthAvailable(self):
        """get available bandwidth.
        """
        theoreticalMaximumBandwidth = self.getMaxBandwidthTheorical()
        usedBandwidth = self.getBandwidthUsed()
        if self.stat_unit != "bit":
            usedBandwidth = usedBandwidth * 8
        return (theoreticalMaximumBandwidth - usedBandwidth)

    def _handle_PortStatsEv(self, event):
        """PortStatsEvent handler
            update self stat data.
        """
        now = time.time()
        stats = event.stats
        dpid = event.dpid
        self.stat_unit  = event.unit

        for stat in stats:
            port =  stat['port_no']
            # we only look for dst_ofp and dst_ofs because we use rx_bytes
            if (port != of.ofp_port_rev_map["OFPP_LOCAL"] and
                port == self.dst_ofp.number and
                dpid == self.dst_ofp.ofs.dpid):
                log.debug("update stat :dpid = %s, port = %s" % (str(dpid), str(port)))
                self.update_stat(stat['rx_bytes'], now, self.stat_unit)

    def update_stat(self, rx_bytes, now, stat_unit):
        """update stat data
            rx_bytes  -- read data byte count.
            now       -- time.
            stat_unit -- rx_byte unit.
        """
        before = copy.copy(self) # shallow copy. it's enough, because change state is only own dict.
        if stat_unit == "bit":
            rx_bytes = rx_bytes * 8

        if  now - self.time >= 1.00:
            self.__update_used_bw__(rx_bytes, now)
            self.raiseEvent(ScnLinkUpdatedEv, self, before)
        else:
            log.warn("no update beaause time diff. now=%s, self=%s" % (str(now), str(self.time)))

    def __update_used_bw__(self, rx_bytes, now):
        self.used_bw = (rx_bytes - self.rx_bytes) / float(now - self.time)
        self.rx_bytes = rx_bytes
        self.time = now
        log.debug("update link bandwidth :%s" % str(self))

    def __str__(self):
        s = "%s [%s -> %s]" % (self._id, self.src_ofp, self.dst_ofp)

        unit = "B"
        if self.stat_unit == "bit":
            unit = "bits"

        s += "\n"
        used = self.getBandwidthUsed()
        s += '<used=%s, ' % ScnLink.__get_with_unit_prefix__(used, unit)
        avail = self.getBandwidthAvailable()
        s += 'avail=%s, ' % ScnLink.__get_with_unit_prefix__(avail, unit)
        theorical = self.getMaxBandwidthTheorical()
        s += 'theorical=%s>' % ScnLink.__get_with_unit_prefix__(theorical, unit)

        return s

    def to_json(self):
        """jsonize.
        """
        return json.dumps({
            "id"   : self._id,
            "time" : self.time,
            "src" : {
                "port" : self.src_ofp.number,
                "dpid" : self.src_ofp.ofs.dpid
            },
            "dst" : {
                "port" : self.dst_ofp.number,
                "dpid" : self.dst_ofp.ofs.dpid
            },
            "stat_unit" : self.stat_unit,
            "used_bw"   : self.getBandwidthUsed(),
            "avail"     : self.getBandwidthAvailable(),
            "theoircal" : self.getMaxBandwidthTheorical(),
            "rx_bytes"  : self.rx_bytes
        })

    @classmethod
    def __get_with_unit_prefix__(cls, value, unit):
        """get string bandwidth with unit.
        """
        prefix = ""
        if 10**3 < value and value < 10**6:
            value = value/10**3
            prefix = "K"
        elif 10**6 < value and value < 10**9:
            value = value/10**6
            prefix = "M"
        elif 10**9 < value and value < 10**12:
            value = value/10**9
            prefix = "G"
        return '%.3f %s%s/s' % (value, prefix, unit)


    # below is shorthand Discovery.Link.
    # need use Discovery Class.
    @property
    def dpid1(self):
        return self.src_ofp.ofs.dpid

    @dpid1.setter
    def dpid1(self, value):
        raise AttributeError("cannot change dpid1 value.%s" % value)

    @property
    def dpid2(self):
        return self.dst_ofp.ofs.dpid

    @dpid2.setter
    def dpid2(self, value):
        raise AttributeError("cannot change dpid2 value.%s" % value)

    @property
    def port1(self):
        return self.src_ofp.number

    @port1.setter
    def port1(self, value):
        raise AttributeError("cannot change port1 value.%s" % value)

    @property
    def port2(self):
        return self.dst_ofp.number

    @port2.setter
    def port2(self, value):
        raise AttributeError("cannot change port2 value.%s" % value)

    @property
    def ofp1(self):
        return self.src_ofp

    @ofp1.setter
    def ofp1(self, value):
        raise AttributeError("cannot change ofp1 value.%s" % value)

    @property
    def ofp2(self):
        return self.dst_ofp

    @ofp2.setter
    def ofp2(self, value):
        raise AttributeError("cannot change ofp2 value.%s" % value)

    @property
    def ofs1(self):
        return self.src_ofp.ofs

    @ofs1.setter
    def ofs1(self, value):
        raise AttributeError("cannot change ofs1 value.%s" % value)

    @property
    def ofs2(self):
        return self.dst_ofp.ofs

    @ofs2.setter
    def ofs2(self, value):
        raise AttributeError("cannot change ofs2 value.%s" % value)


class ScnOpenFlowHost(EventMixin, Host):
    """describe Node(Host) on ScnOpenFlow space.
    """
    _eventMixin_events = set([
        HostJoin, # Defined in pox.topology
        HostLeave,
    ])

    def __init__(self, macAddr, ofp, ipAddr = None):
        if not macAddr:
            raise AssertionError("ScnOpenFlowHost should have a Mac address")

        Host.__init__(self)
        EventMixin.__init__(self)
        self.macAddr = macAddr
        self.ipAddr = ipAddr
        self.ofp = ofp
        log.debug("ScnOpenFlowHost :%s", str(self))

    def __str__ (self):
        return "<%s|%s|%s|%s>" % (
              self.__class__.__name__,
              str(self.macAddr),
              str(self.ipAddr),
              str(self.ofp)
          )

class ofp_port_features:
    """port features from ofp phi event.
    """
    ofp_port_features = [
            'OFPPF_10MB_HD',
            'OFPPF_10MB_FD',
            'OFPPF_100MB_HD',
            'OFPPF_100MB_FD',
            'OFPPF_1GB_HD',
            'OFPPF_1GB_FD',
            'OFPPF_10GB_FD',
            'OFPPF_COPPER',
            'OFPPF_FIBER',
            'OFPPF_AUTONEG',
            'OFPPF_PAUSE',
            'OFPPF_PAUSE_ASYM'
        ]
    OFPPF_10MB_HD     = 1
    OFPPF_10MB_FD     = 2
    OFPPF_100MB_HD    = 4
    OFPPF_100MB_FD    = 8
    OFPPF_1GB_HD      = 16
    OFPPF_1GB_FD      = 32
    OFPPF_10GB_FD     = 64
    OFPPF_COPPER      = 128
    OFPPF_FIBER       = 256
    OFPPF_AUTONEG     = 512
    OFPPF_PAUSE       = 1024
    OFPPF_PAUSE_ASYM  = 2048
    ofp_port_features_map = {
        1      : 'OFPPF_10MB_HD',
        2      : 'OFPPF_10MB_FD',
        4      : 'OFPPF_100MB_HD',
        8      : 'OFPPF_100MB_FD',
        16     : 'OFPPF_1GB_HD',
        32     : 'OFPPF_1GB_FD',
        64     : 'OFPPF_10GB_FD',
        128    : 'OFPPF_COPPER',
        256    : 'OFPPF_FIBER',
        512    : 'OFPPF_AUTONEG',
        1024   : 'OFPPF_PAUSE',
        2048   : 'OFPPF_PAUSE_ASYM'
    }

    def __init__(self):
        pass

    @classmethod
    def unpackSpeed(cls, curr):
        """get spped (bits/s) from phi event.
        """
        # in Mbits/s
        speed = 0.
        if curr & (cls.OFPPF_10MB_HD | cls.OFPPF_10MB_FD):
            speed = 10.
        elif curr & (cls.OFPPF_100MB_HD | cls.OFPPF_100MB_FD):
            speed = 100.
        elif curr & (cls.OFPPF_1GB_HD | cls.OFPPF_1GB_FD):
            speed = 1000.
        elif curr & cls.OFPPF_10GB_FD:
            speed = 10000.
        return speed * 10**6 # return bits/s


class ScnOpenFlowPort(OpenFlowPort):
    """describe OpenFlowPort on ScnOpenFlow space.
    """
    def __init__(self, ofp, ofs, ipAddr = None, speed = None):
        OpenFlowPort.__init__(self, ofp)
        self.ofs = ofs
        self.ipAddr = ipAddr
        if speed:
            self.max_speed = speed
        else:
            self.max_speed = ofp_port_features.unpackSpeed(ofp.curr)
        log.debug("ScnOpenFlowPort init : %s" % str(self))

    def getHosts(self):
        """get all host entries.
        """
        return [entity for entity in self.entities if isinstance(entity, ScnOpenFlowHost)]

    def getHost(self, locator):
        """get specified host entry.
            locator[EthAddr/IPAddr] -- host address.
        """
        log.debug("getHost self=[%s], o=[%s]" % (str(self), str(locator)))
        if isinstance(locator, EthAddr):
            return self.getHostByMac(locator)
        if isinstance(locator, IPAddr):
            return self.getHostByIp(locator)
        log.error("getHost, unknown class: %s" % locator.__class__)

    def getHostByMac(self, mac):
        """get host entry by Mac address.
        """
        for entity in self.entities:
            if not isinstance(entity, ScnOpenFlowHost):
                continue
            if entity.macAddr != mac:
                continue
            return entity
        return

    def getHostByIp(self, ip):
        """get host entry by IP address.
        """
        log.debug("getHostByIp o=[%s]" % str(ip))
        for entity in self.entities:
            if not isinstance(entity, ScnOpenFlowHost):
                continue
            log.debug("ScnOpenFlowHost Enitity [%s]" % str(entity))
            if entity.ipAddr != ip:
                continue
            return entity
        return

    def __str__(self):
        return "<[%s] %d:%d:%s>" % (
                self.__class__.__name__,
                self.ofs.dpid,
                self.number,
                str(self.ipAddr)
            )


class ScnOpenFlowSwitch(OpenFlowSwitch):
    """describe OpenFlowSwitch on ScnOpenFlow space.
    """
    def __init__(self, sw, topo):
        OpenFlowSwitch.__init__(self, sw)
        self.topo = topo
        self.table = SwitchFlowTable()
        log.debug("ScnOpenFlowSwitch init : %s" % str(self))

    def _getIniOfpSpeed(self, target_port):
        """get ofp max spped setting.
        """
        ofs_ip = self.ipaddr
        for section in core.parser.getSwitchsSections():
            ip = core.parser.getValue(section, IP)
            if ip != ofs_ip:
                continue
            ports = core.parser.getPortsSections(section)
            for port in ports:
                #log.debug("port = %s" % port)
                name = core.parser.getValue(port, INTFNAME)
                if target_port.name != name:
                    continue
                speed = core.parser.getValue(port, SPEED)
                if not speed:
                    return None
                factor = 1.
                speed = speed.lower()
                if speed[-1] == "k":
                    factor = 10.**3
                    speed = speed[:-1]
                elif speed[-1] == "m":
                    factor = 10.**6
                    speed = speed[:-1]
                elif speed[-1] == "g":
                    factor = 10.**9
                    speed = speed[:-1]
                return float(speed) * factor

    def setConnection(self, connection, ofp = None):
        """set connection listener.
            ofp - a FeaturesReply message
        """
        if self._connection:
            self._connection.removeListeners(self._listeners)
        self._listeners = []
        self._connection = connection
        if self._reconnectTimeout is not None:
            self._reconnectTimeout.cancel()
            self._reconnectTimeout = None
        if connection is None:
            self._reconnectTimeout = Timer(RECONNECT_TIMEOUT,
                                         self._timer_ReconnectTimeout)
        if ofp is not None:
            # update capabilities
            self.capabilities = ofp.capabilities
            # update all ports
            untouched = set(self.ports.keys())
            for port in ofp.ports:
                if port.port_no in self.ports:
                    self.ports[port.port_no]._update(port) # _update method is protected.
                    untouched.remove(port.port_no)
                else:
                    speed = self._getIniOfpSpeed(port)
                    log.debug("New ScnOpenFlowPort: [%s] OFP = %s" % (str(port), str(ofp)))
                    self.ports[port.port_no] = ScnOpenFlowPort(port, self, speed = speed)
            for port in untouched:
                log.debug("remove ports: [%s]" % str(port))
                self.ports[port].exists = False
                del self.ports[port]
        if connection is not None:
            self._listeners = self.listenTo(connection, prefix = "con")
            self.raiseEvent(SwitchConnectionUp(switch = self, connection = connection))
        else:
            self.raiseEvent(SwitchConnectionDown(switch = self))

    def _handle_con_PortStatus(self, event):
        port = event.ofp.desc
        if event.ofp.reason == of.ofp_port_reason_rev_map["OFPPR_DELETE"]:
            if port.port_no in self.ports:
                self.ports[port.port_no].exists = False
                del self.ports[port.port_no]
        elif event.ofp.reason == of.ofp_port_reason_rev_map["OFPPR_MODIFY"]:
            self.ports[port.port_no]._update(port) # _update method is protected.
        else:
            assert event.ofp.reason == of.ofp_port_reason_rev_map["OFPPR_ADD"]
            assert port.port_no not in self.ports
            speed = self._getIniOfpSpeed(port)
            log.debug("New ScnOpenFlowPort: [%s] OFP = %s" % (str(port), str(event.ofp)))
            self.ports[port.port_no] = ScnOpenFlowPort(port, self, speed = speed)
        self.raiseEvent(event)
        event.halt = False

    @property
    def ipaddr(self):
        """IP Address attribute.(getter)
        """
        ip = IPAddr(self._connection.sock.getpeername()[0])
        log.debug("[IP] get IP: %s" % str(ip))
        return ip

    def getPorts(self):
        """get all ScnOpenFlowPort.
        """
        return self.ports.values()

    def getOFPort(self, number):
        """get a ScnOpenFlowPort specified by number.
        """
        for port in self.ports.values():
            if port.number == number:
                return port
        return None

    def getHost(self, locator):
        """get a ScnOpenFlowHost specified by locator.
            use ScnOpenFlowPort.getHost
        """
        log.debug("getHost self=[%s], o=[%s]" % (str(self), str(locator)))
        assert isinstance(locator, EthAddr) or isinstance(locator, IPAddr)
        for ofp in self.ports.values():
            host = ofp.getHost(locator)
            if host:
                return host

    def __receive_flow_mod__(self, ofp):
        """Handle flow mod: just print it here
        """
        log.debug("Flow mod %s: %s" % (self.name, ofp.show()))
        self.table.process_flow_mod(ofp)

    def installFlow(self, msg):
        """@override
            because base class has bug. no import TableEntry...
            and extend input struct to flow_mod object.
        """
        tabEntry = TableEntry.from_flow_mod(msg)
        log.info("apply entry - %s" % str(tabEntry))
        self.flow_table.install(tabEntry)

    def removeFlow(self, msg):
        """remove flow entry.
            msg[flow_mod] -- entry msg object.
        """
        tabEntry = TableEntry.from_flow_mod(msg)
        log.info("remove entry - %s" % str(tabEntry))
        self.flow_table.remove_with_wildcards(tabEntry)


class ScnOpenFlowTopology(OpenFlowTopology):

    """ Note that self.topology is initialized in _resolveComponents --> what mean? """
    def _handle_openflow_discovery_LinkEvent(self, event):
        if self.topology is None:
            log.warn("no topology modules.")
            return
        link = event.link
        sw1 = self.topology.getEntityByID(link.src_ofp.ofs.dpid)
        sw2 = self.topology.getEntityByID(link.dst_ofp.ofs.dpid)
        if sw1 is None or sw2 is None:
            log.warn("no switch 1 or 2.")
            return

        port1 = link.src_ofp.number
        port2 = link.dst_ofp.number

        if port1 not in sw1.ports or port2 not in sw2.ports:
            log.warn("no match. port not in sw ports.")
            return
        if event.added:
            sw1.ports[port1].addEntity(sw2, single = True)
            sw2.ports[port2].addEntity(sw1, single = True)
        elif event.removed:
            sw1.ports[port1].entities.discard(sw2)
            sw2.ports[port2].entities.discard(sw1)

    def _handle_openflow_ConnectionUp(self, event):
        sw = self.topology.getOFS(event.dpid)

        add = False
        if sw is None:
            sw = ScnOpenFlowSwitch(event.dpid, self)
            add = True
        else:
            if sw._connection is not None: # _connection is protected.
                log.warn("Switch %s connected, but... it's already connected!" %
                         (dpidToStr(event.dpid),))
        log.debug("[_handle_openflow_ConnectionUp] OFP ? [%s] " % str(event.ofp))
        sw.setConnection(event.connection, event.ofp)
        log.info("Switch " + dpidToStr(event.dpid) + " connected")
        if add:
            self.topology.addEntity(sw)
            sw.raiseEvent(SwitchJoin, sw)

#______________________________________________________________________________#
#                                   Launcher                                   #
#______________________________________________________________________________#

def launch():
    """start trriger.
        called from nwgn.py.
    """
    name = "openflow_topology"

    if not core.hasComponent(name):
        core.register(name, ScnOpenFlowTopology())

